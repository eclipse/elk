/*******************************************************************************
 * Copyright (c) 2015, 2020 Kiel University and others.
 * 
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 *******************************************************************************/
package org.eclipse.elk

import java.util.EnumSet
import org.eclipse.elk.core.data.LayoutAlgorithmData
import org.eclipse.elk.core.^labels.ILabelManager
import org.eclipse.elk.core.math.ElkMargin
import org.eclipse.elk.core.math.ElkPadding
import org.eclipse.elk.core.math.KVector
import org.eclipse.elk.core.math.KVectorChain
import org.eclipse.elk.core.util.BoxLayoutProvider
import org.eclipse.elk.core.util.BoxLayoutProvider.PackingMode
import org.eclipse.elk.core.util.ExclusiveBounds
import org.eclipse.elk.core.util.FixedLayoutProvider
import org.eclipse.elk.core.util.IndividualSpacings
import org.eclipse.elk.core.util.RandomLayoutProvider

// Sort based on normal - advanced - programmatic - global - output and within the groups alphabetically
// If different types are within a group, move the group to the first category 

/**
 * Core definitions of the Eclipse Layout Kernel.
 */
bundle {
    label "ELK"
    metadataClass core.options.CoreOptions
    idPrefix org.eclipse.elk 
}

category layered {
    label "Layered"
    description
        "The layer-based method was introduced by Sugiyama, Tagawa and Toda in 1981. It emphasizes
        the direction of edges by pointing as many edges as possible into the same direction.
        The nodes are arranged in layers, which are sometimes called \"hierarchies\", and then
        reordered such that the number of edge crossings is minimized. Afterwards, concrete
        coordinates are computed for the nodes and edge bend points."
}

category orthogonal {
    label "Orthogonal"
    description
        "Orthogonal methods that follow the \"topology-shape-metrics\" approach by Batini,
        Nardelli and Tamassia '86. The first phase determines the topology of the drawing by
        applying a planarization technique, which results in a planar representation of the graph.
        The orthogonal shape is computed in the second phase, which aims at minimizing the number
        of edge bends, and is called orthogonalization. The third phase leads to concrete
        coordinates for nodes and edge bend points by applying a compaction method, thus defining
        the metrics."
}

category force {
    label "Force"
    description
        "Layout algorithms that follow physical analogies by simulating a system of attractive and
        repulsive forces. The first successful method of this kind was proposed by Eades in 1984."
}

category circle {
    label "Circle"
    description
        "Circular layout algorithms emphasize cycles or biconnected components of a graph by
        arranging them in circles. This is useful if a drawing is desired where such components
        are clearly grouped, or where cycles are shown as prominent OPTIONS of the graph."
}

category tree {
    label "Tree"
    description
        "Specialized layout methods for trees, i.e. acyclic graphs. The regular structure of graphs
        that have no undirected cycles can be emphasized using an algorithm of this type."
}

category planar {
    label "Planar"
    description
        "Algorithms that require a planar or upward planar graph. Most of these algorithms are 
        theoretically interesting, but not practically usable."
}

category radial {
    label "Radial"
    description
        "Radial layout algorithms usually position the nodes of the graph on concentric circles."
}

//------- UTILITY ALGORITHMS
algorithm fixed(FixedLayoutProvider) {
    label "ELK Fixed"
    description
        "Keeps the current layout as it is, without any automatic modification. Optional coordinates
        can be given for nodes and edge bend points."
    metadataClass core.options.FixedLayouterOptions 
    supports padding = new ElkPadding(15)
    supports position
    supports bendPoints
    supports nodeSize.constraints
    supports nodeSize.minimum
    supports nodeSize.fixedGraphSize
}

algorithm box(BoxLayoutProvider) {
    label "ELK Box"
    description
        "Algorithm for packing of unconnected boxes, i.e. graphs without edges."
    metadataClass core.options.BoxLayouterOptions
    preview images/box_layout.png
    supports padding = new ElkPadding(15)
    supports spacing.nodeNode = 15
    supports priority = 0
    documentation "Priorities set on nodes determine the order in which they are placed:
            boxes with a higher priority will end up before boxes with a lower priority.
            Boxes with equal priorities are sorted from smaller to bigger
            unless the layout algorithm is set to interactive mode."
    supports expandNodes
    supports nodeSize.constraints
    supports nodeSize.options
    supports aspectRatio = 1.3f
    supports interactive
    supports nodeSize.minimum
    supports box.packingMode
    supports contentAlignment
}

group box {

    option packingMode: PackingMode {
        label "Box Layout Mode"
        description
            "Configures the packing mode used by the {@link BoxLayoutProvider}.
             If SIMPLE is not required (neither priorities are used nor the interactive mode),
             GROUP_DEC can improve the packing and decrease the area. 
             GROUP_MIXED and GROUP_INC may, in very specific scenarios, work better."
        default = BoxLayoutProvider.PackingMode.SIMPLE
        targets parents
    }

}

algorithm random(RandomLayoutProvider) {
    label "ELK Randomizer"
    description
        "Distributes the nodes randomly on the plane, leading to very obfuscating layouts. Can be
        useful to demonstrate the power of \"real\" layout algorithms."
    metadataClass core.options.RandomLayouterOptions
    preview images/random_layout.png
    supports padding = new ElkPadding(15)
    supports spacing.nodeNode = 15
    supports randomSeed = 0
    supports aspectRatio = 1.6f
}

//------- UI OPTIONS 
option ^algorithm: String {
    label "Layout Algorithm"
    description
        "Select a specific layout algorithm."
    targets parents
}

programmatic option resolvedAlgorithm: LayoutAlgorithmData {
    label "Resolved Layout Algorithm"
    description
        "Meta data associated with the selected algorithm."
    targets parents
}

advanced option alignment: Alignment {
    label "Alignment"
    description
        "Alignment of the selected node relative to other nodes;
        the exact meaning depends on the used algorithm."
    default = Alignment.AUTOMATIC
    targets nodes
}

advanced option aspectRatio: double {
    label "Aspect Ratio"
    description
        "The desired aspect ratio of the drawing, that is the quotient of width by height."
    lowerBound = ExclusiveBounds.greaterThan(0)
    targets parents
}

programmatic option bendPoints: KVectorChain {
    label "Bend Points"
    description
        "A fixed list of bend points for the edge. This is used by the 'Fixed Layout' algorithm to
        specify a pre-defined routing for an edge. The vector chain must include the source point,
        any bend points, and the target point, so it must have at least two points."
    targets edges
}

advanced option contentAlignment: EnumSet<ContentAlignment> {
    label "Content Alignment"
    description
        "Specifies how the content of a node are aligned. Each node can individually control the alignment of its
         contents. I.e. if a node should be aligned top left in its parent node, the parent node should specify that
         option."
    default = ContentAlignment.topLeft()
    targets parents
}

advanced option debugMode: boolean {
    label "Debug Mode"
    description
        "Whether additional debug information shall be generated."
    default = false
    targets parents
}

option direction: Direction {
    label "Direction"
    description
        "Overall direction of edges: horizontal (right / left) or
        vertical (down / up)."
    default = Direction.UNDEFINED
    targets parents
}

option edgeRouting: EdgeRouting {
    label "Edge Routing"
    description
        "What kind of edge routing style should be applied for the content of a parent node.
        Algorithms may also set this option to single edges in order to mark them as splines.
        The bend point list of edges with this option set to SPLINES must be interpreted as control
        points for a piecewise cubic spline."
    default = EdgeRouting.UNDEFINED
    targets parents
}

advanced option expandNodes: boolean {
    label "Expand Nodes"
    // TODO improve description, e.g. what is 'expand'
    description
        "If active, nodes are expanded to fill the area of their parent."
    default = false
    targets parents
}

advanced option hierarchyHandling: HierarchyHandling {
    label "Hierarchy Handling"
    description
        "Determines whether separate layout runs are triggered for different compound nodes in a
        hierarchical graph. Setting a node's hierarchy handling to `INCLUDE_CHILDREN` will lay
        out that node and all of its descendants in a single layout run, until a descendant is
        encountered which has its hierarchy handling set to `SEPARATE_CHILDREN`. In general,
        `SEPARATE_CHILDREN` will ensure that a new layout run is triggered for a node with that
        setting. Including multiple levels of hierarchy in a single layout run may allow
        cross-hierarchical edges to be laid out properly. If the root node is set to `INHERIT`
        (or not set at all), the default behavior is `SEPARATE_CHILDREN`."
    default = HierarchyHandling.INHERIT
    targets parents, nodes
}

advanced option padding: ElkPadding {
    label "Padding"
    description
        "The padding to be left to a parent element's border when placing child elements. This can
        also serve as an output option of a layout algorithm if node size calculation is setup
        appropriately."
    default = new ElkPadding(12)
    targets parents, nodes
}

advanced option interactive: boolean {
    label "Interactive"
    description
        "Whether the algorithm should be run in interactive mode for the content of a parent node.
        What this means exactly depends on how the specific algorithm interprets this option.
        Usually in the interactive mode algorithms try to modify the current layout as little as
        possible."
    default = false
    targets parents
}

advanced option interactiveLayout: boolean {
    label "interactive Layout"
    description
        "Whether the graph should be changeable interactively and by setting constraints"
    default = false
    targets parents
}

advanced option omitNodeMicroLayout: boolean {
    label "Omit Node Micro Layout"
    description
        "Node micro layout comprises the computation of node dimensions (if requested), the placement of ports 
         and their labels, and the placement of node labels. 
         The functionality is implemented independent of any specific layout algorithm and shouldn't have any 
         negative impact on the layout algorithm's performance itself. Yet, if any unforeseen behavior occurs,
         this option allows to deactivate the micro layout."
    default = false
    targets parents
}

// --- SPACING
group spacing {
    
    option commentComment: double {
        label "Comment Comment Spacing"
        description
            "Spacing to be preserved between a comment box and other comment boxes connected to the same node.
            The space left between comment boxes of different nodes is controlled by the node-node spacing."
        default = 10
        lowerBound = 0.0
        targets parents
    }
    
    option commentNode: double {
        label "Comment Node Spacing"
        description
            "Spacing to be preserved between a node and its connected comment boxes. The space left between a node
            and the comments of another node is controlled by the node-node spacing."
        default = 10
        lowerBound = 0.0
        targets parents
    }

    option componentComponent: double {
        label "Components Spacing"
        description
            "Spacing to be preserved between pairs of connected components. 
            This option is only relevant if 'separateConnectedComponents' is activated."
        default = 20f
        lowerBound = 0.0
        targets parents
    }

    option edgeEdge: double {
        label "Edge Spacing"
        description
            "Spacing to be preserved between any two edges. Note that while this can somewhat easily be satisfied 
            for the segments of orthogonally drawn edges, it is harder for general polylines or splines."
        default = 10
        lowerBound = 0.0
        targets parents
    }

    option edgeLabel: double {
        label "Edge Label Spacing"
        description
            "The minimal distance to be preserved between a label and the edge it is associated with.
            Note that the placement of a label is influenced by the 'edgelabels.placement' option."
        default = 2
        lowerBound = 0.0
        targets parents
    }

    option edgeNode: double {
        label "Edge Node Spacing"
        description
            "Spacing to be preserved between nodes and edges."
        default = 10
        lowerBound = 0.0
        targets parents   
    }

    option labelLabel: double {
        label "Label Spacing"
        description
            "Determines the amount of space to be left between two labels 
             of the same graph element."
        default = 0
        lowerBound = 0.0
        targets parents
    }

    option labelNode: double {
        label "Label Node Spacing"
        description
            "Spacing to be preserved between labels and the border of node they are associated with. 
            Note that the placement of a label is influenced by the 'nodelabels.placement' option."
        default = 5
        lowerBound = 0.0
        targets parents
    }

    option labelPort: double {
        label "Label Port Spacing"
        description
            "Spacing to be preserved between labels and the ports they are associated with. 
            Note that the placement of a label is influenced by the 'portlabels.placement' option."
        default = 1
        lowerBound = 0.0
        targets parents
    }

    option nodeNode: double {
        label "Node Spacing"
        description
            "The minimal distance to be preserved between each two nodes."
        default = 20
        lowerBound = 0.0
        targets parents
    }

    option nodeSelfLoop: double {
        label "Node Self Loop Spacing"
        description
            "Spacing to be preserved between a node and its self loops."
        default = 10
        lowerBound = 0.0
        targets parents
    }

    option portPort: double {
        label "Port Spacing"
        description
            "Spacing between pairs of ports of the same node."
        default = 10
        lowerBound = 0.0
        targets parents, nodes
    }

    advanced option individual: IndividualSpacings {
        label "Individual Spacing"
        description 
            "Allows to specify individual spacing values for graph elements that shall be different from 
            the value specified for the element's parent."
        documentation
            "In most cases, spacing values apply to the children of the hierarchical node 
            (possibly the root node) for which the values are actually specified. 
            Hereby, the children may include ports, edges, and labels.
            This option allows to specify a different spacing for a certain element, 
            thus overriding the parent's value. To give an example, a spacing.portPort of 5 configured 
            on the graph would result in the ports of all of the graph's nodes to be spaced apart by 5px. 
            A single node may desire a larger spacing and hence set an individual spacing.portPort of 10.
            Note that not all algorithms (or concrete configurations of a specific algorithm)
            support this behavior.

            When specified as a string (in elkg or elkt) the individual options must be separated by ';,;'.
            Example: \"spacing.portPort:5;,;spacing.nodeNode:10\""
        targets nodes, edges, ports, labels
    }

    advanced option portsSurrounding: ElkMargin {
        label "Additional Port Space"
        description
            "Additional space around the sets of ports on each node side. For each side of a node,
            this option can reserve additional space before and after the ports on each side. For
            example, a top spacing of 20 makes sure that the first port on the western and eastern
            side is 20 units away from the northern border."
        default = new ElkMargin(0)
        targets parents
    }

}

// --- PARTITIONING 
group partitioning {

    advanced option partition: Integer {
        label "Layout Partition"
        description
            "Partition to which the node belongs. This requires Layout Partitioning to be active. Nodes with lower
            partition IDs will appear to the left of nodes with higher partition IDs (assuming a left-to-right layout
            direction)."
        targets parents, nodes
        requires activate == true
    }

    advanced option activate: Boolean {
        label "Layout Partitioning"
        description
            "Whether to activate partitioned layout. This will allow to group nodes through the Layout Partition option.
            a pair of nodes with different partition indices is then placed such that the node with lower index is
            placed to the left of the other node (with left-to-right layout direction). Depending on the layout
            algorithm, this may only be guaranteed to work if all nodes have a layout partition configured, or at least
            if edges that cross partitions are not part of a partition-crossing cycle."
        default = false
        targets parents
    }

}

// --- NODE LABELS
group nodeLabels {

    advanced option padding: ElkPadding {
        label "Node Label Padding"
        description
            "Define padding for node labels that are placed inside of a node."
        default = new ElkPadding(5)
        targets parents
    }

    option placement: EnumSet<NodeLabelPlacement> {
        label "Node Label Placement"
        description
            "Hints for where node labels are to be placed; if empty, the node label's position is not
            modified."
        default = NodeLabelPlacement.fixed
        targets nodes, labels
    }

}

// --- PORT ALIGNMENT
group portAlignment {

    option ^default: PortAlignment {
        label "Port Alignment"
        description
            "Defines the default port distribution for a node. May be overridden for each side individually."
        default = PortAlignment.DISTRIBUTED
        targets nodes
    }

    advanced option north: PortAlignment {
        label "Port Alignment (North)"
        description
            "Defines how ports on the northern side are placed, overriding the node's general port alignment."
        targets nodes
    }

    advanced option south: PortAlignment {
        label "Port Alignment (South)"
        description
            "Defines how ports on the southern side are placed, overriding the node's general port alignment."
        targets nodes
    }

    advanced option west: PortAlignment {
        label "Port Alignment (West)"
        description
            "Defines how ports on the western side are placed, overriding the node's general port alignment."
        targets nodes
    }

    advanced option east: PortAlignment {
        label "Port Alignment (East)"
        description
            "Defines how ports on the eastern side are placed, overriding the node's general port alignment."
        targets nodes
    }

}

option portConstraints: PortConstraints {
    label "Port Constraints"
    description
        "Defines constraints of the position of the ports of a node."
    default = PortConstraints.UNDEFINED
    targets nodes
}

advanced option position: KVector {
    label "Position"
    description
        "The position of a node, port, or label. This is used by the 'Fixed Layout' algorithm to
        specify a pre-defined position."
    targets nodes, ports, labels
}

advanced option priority: int {
    label "Priority"
    description
        "Defines the priority of an object; its meaning depends on the specific layout algorithm
        and the context where it is used."
    targets nodes, edges
}

advanced option randomSeed: int {
    label "Randomization Seed"
    description
        "Seed used for pseudo-random number generators to control the layout algorithm. If the
        value is 0, the seed shall be determined pseudo-randomly (e.g. from the system time)."
    targets parents
}

option separateConnectedComponents: boolean {
    label "Separate Connected Components"
    description
        "Whether each connected component should be processed separately."
    targets parents
}

// --- NODE SIZE
group nodeSize {

    option constraints: EnumSet<SizeConstraint> {
        label "Node Size Constraints"
        description
            "What should be taken into account when calculating a node's size. Empty size constraints
            specify that a node's size is already fixed and should not be changed."
        documentation "@sizeconstraints.md"
        default = EnumSet.noneOf(SizeConstraint)
        targets nodes
    }

    option options: EnumSet<SizeOptions> {
        label "Node Size Options"
        description
            "Options modifying the behavior of the size constraints set on a node. Each member of the
            set specifies something that should be taken into account when calculating node sizes.
            The empty set corresponds to no further modifications."
        documentation "@sizeoptions.md"
        default = EnumSet.of(SizeOptions.DEFAULT_MINIMUM_SIZE)
        targets nodes
    }

    advanced option minimum: KVector {
        label "Node Size Minimum"
        description
            "The minimal size to which a node can be reduced."
        default = new KVector(0, 0)
        targets nodes
    }

    option fixedGraphSize: boolean {
        label "Fixed Graph Size"
        description
            "By default, the fixed layout provider will enlarge a graph until it is large enough to contain
            its children. If this option is set, it won't do so."
        default = false
        targets parents
    }

}

//------- PROGRAMMATIC OPTIONS
output option junctionPoints: KVectorChain {
    label "Junction Points"
    description
        "This option is not used as option, but as output of the layout algorithms. It is
        attached to edges and determines the points where junction symbols should be drawn in
        order to represent hyperedges with orthogonal routing. Whether such points are computed
        depends on the chosen layout algorithm and edge routing style. The points are put into
        the vector chain with no specific order."
    targets edges
    default = new KVectorChain()
}

option commentBox: boolean {
    label "Comment Box"
    description
        "Whether the node should be regarded as a comment box instead of a regular node. In that
        case its placement should be similar to how labels are handled. Any edges incident to a
        comment box specify to which graph elements the comment is related."
    default = false
    targets nodes
}

// --- EDGE LABELS
group edgeLabels {

    option placement: EdgeLabelPlacement {
        label "Edge Label Placement"
        description
            "Gives a hint on where to put edge labels."
        default = EdgeLabelPlacement.CENTER
        targets labels
    }

    option inline: boolean {
        label "Inline Edge Labels"
        description
            "If true, an edge label is placed directly on its edge. May only apply to center edge labels.
            This kind of label placement is only advisable if the label's rendering is such that it is not
            crossed by its edge and thus stays legible."
        default = false
        targets labels
    }

}

// --- FONT
group font {

    programmatic option name: String {
        label "Font Name"
        description
            "Font name used for a label."
        targets labels
    }

    programmatic option size: int {
        label "Font Size"
        description
            "Font size used for a label."
        lowerBound = 1
        targets labels
    }

}

programmatic option hypernode: boolean {
    label "Hypernode"
    description
        "Whether the node should be handled as a hypernode."
    default = false
    targets nodes
}

programmatic option labelManager: ILabelManager {
    label "Label Manager"
    description
        "Label managers can shorten labels upon a layout algorithm's request."
    targets parents, labels
}

option margins: ElkMargin {
    label "Margins"
    description
        "Margins define additional space around the actual bounds of a graph element. For instance,
        ports or labels being placed on the outside of a node's border might introduce such a
        margin. The margin is used to guarantee non-overlap of other graph elements with those
        ports or labels."
    default = new ElkMargin()
    targets nodes
}

option noLayout: boolean {
    label "No Layout"
    description
        "No layout is done for the associated element. This is used to mark parts of a diagram to
        avoid their inclusion in the layout graph, or to mark parts of the layout graph to
        prevent layout engines from processing them. If you wish to exclude the contents of a
        compound node from automatic layout, while the node itself is still considered on its own
        layer, use the 'Fixed Layout' algorithm for that node."
    default = false
    targets nodes, edges, ports, labels
}

// --- PORT
group port {

    option anchor: KVector {
        label "Port Anchor Offset"
        description
            "The offset to the port position where connections shall be attached."
        targets ports
    }

    option index: int {
        label "Port Index"
        description
            "The index of a port in the fixed order around a node. The order is assumed as clockwise,
            starting with the leftmost port on the top side. This option must be set if 'Port
            Constraints' is set to FIXED_ORDER and no specific positions are given for the ports.
            Additionally, the option 'Port Side' must be defined in this case."
        targets ports
    }

    option side: PortSide {
        label "Port Side"
        description
            "The side of a node on which a port is situated. This option must be set if 'Port
            Constraints' is set to FIXED_SIDE or FIXED_ORDER and no specific positions are given
            for the ports."
        default = PortSide.UNDEFINED
        targets ports
    }

    option borderOffset: double {
        label "Port Border Offset"
        description
            "The offset of ports on the node border. With a positive offset the port is moved outside
            of the node, while with a negative offset the port is moved towards the inside. An offset
            of 0 means that the port is placed directly on the node border, i.e.
            if the port side is north, the port's south border touches the nodes's north border;
            if the port side is east, the port's west border touches the nodes's east border;
            if the port side is south, the port's north border touches the node's south border;
            if the port side is west, the port's east border touches the node's west border."
        targets ports
    }

}

// --- PORT LABELS
group portLabels {

    option placement: EnumSet<PortLabelPlacement> {
        label "Port Label Placement"
        description
            "Decides on a placement method for port labels; if empty, the node label's position is not
            modified."
        default = PortLabelPlacement.outside
        targets nodes
    }

    deprecated option nextToPortIfPossible: boolean {
        label "Port Labels Next to Port"
        description
            "Use 'portLabels.placement': NEXT_TO_PORT_OF_POSSIBLE."
        default = false
        targets nodes
    }

    option treatAsGroup: boolean {
        label "Treat Port Labels as Group"
        description
            "If this option is true (default), the labels of a port will be treated as a group when
           it comes to centering them next to their port. If this option is false, only the first label will
           be centered next to the port, with the others being placed below. This only applies to labels of
           eastern and western ports and will have no effect if labels are not placed next to their port."
        default = true
        targets nodes
    }

}

programmatic option scaleFactor: double {
    label "Scale Factor"
    description
        "The scaling factor to be applied to the corresponding node in recursive layout. It causes
        the corresponding node's size to be adjusted, and its ports and labels to be sized and
        placed accordingly after the layout of that node has been determined (and before the node
        itself and its siblings are arranged). The scaling is not reverted afterwards, so the
        resulting layout graph contains the adjusted size and position data. This option is
        currently not supported if 'Layout Hierarchy' is set."
    lowerBound = ExclusiveBounds.greaterThan(0)
    default = 1
    targets nodes
    // TODO
// requires hierarchyHandling != HierarchyHandling.INCLUDE_CHILDREN 
}

programmatic option topdownLayout: boolean {
    label "Topdown Layout"
    description
        "Turns topdown layout on and off. If this option is enabled, hierarchical layout will be computed first for
         the root node and then for its children recursively. Layouts are then scaled down to fit the area provided by
         their parents."
    default = false
}

programmatic option topdownScaleFactor: double {
    label "Topdown Scale Factor"
    description
        "The scaling factor to be applied to the nodes laid out within the node in recursive topdown
         layout. The difference to 'Scale Factor' is that the node itself is not scaled."
    lowerBound = ExclusiveBounds.greaterThan(0)
    default = 1
    targets nodes
}

// TODO: sort options properly
// TODO: decide whether this is a reasonable demand, or whether it would be easier to add this calculation as a 
//       post-processing step that can be added after any algorithm
programmatic option childAreaWidth: double {
    label "Child Area Width"
    description
        "The width of the area occupied by the laid out children of a node. This value is necessary to compute the 
         correct scale factor in topdown layout and must be computed and set by the layout algorithm. This property must
         be set for topdown layout to function."
    targets nodes
}

programmatic option childAreaHeight: double {
    label "Child Area Height"
    description
        "The height of the area occupied by the laid out children of a node. This value is necessary to compute the 
         correct scale factor in topdown layout and must be computed and set by the layout algorithm. This property must
         be set for topdown layout to function."
    targets nodes
}

programmatic option nodeRequiredWidth: double {
    label"Required Node Width"
    description
        "The required width of the node, which has been pre-computed during the layout of its parent and needs to be set 
         again."
}

programmatic option nodeRequiredHeight: double {
    label"Required Node Height"
    description
        "The required height of the node, which has been pre-computed during the layout of its parent and needs to be set 
         again."
}

// --- INSIDE SELF LOOPS
group insideSelfLoops {

    advanced option activate: boolean {
        label "Activate Inside Self Loops"
        description
            "Whether this node allows to route self loops inside of it instead of around it. If set to true,
            this will make the node a compound node if it isn't already, and will require the layout algorithm
            to support compound nodes with hierarchical ports."
        default = false
        targets nodes
    }

    advanced option yo: boolean {
        label "Inside Self Loop"
        description
            "Whether a self loop should be routed inside a node instead of around that node."
        default = false
        targets edges
    }

}

// --- EDGE
group edge {

    programmatic option thickness: double {
        label "Edge Thickness"
        description
            "The thickness of an edge. This is a hint on the line width used to draw an edge, possibly
            requiring more space to be reserved for it."
        default = 1
        targets edges
    }

    // TODO should this be moved to specific options of a layouter that actually supports different edge types?
    programmatic option type: EdgeType {
        label "Edge Type"
        description
            "The type of an edge. This is usually used for UML class diagrams, where associations must
            be handled differently from generalizations."
        default = EdgeType.NONE
        targets edges
    }

}

//------- GLOBAL OPTIONS
global option animate: boolean {
    label "Animate"
    description
        "Whether the shift from the old layout to the new computed layout shall be animated."
    default = true
    targets parents
}

global option animTimeFactor: int {
    label "Animation Time Factor"
    description
        "Factor for computation of animation time. The higher the value, the longer the animation
        time. If the value is 0, the resulting time is always equal to the minimum defined by
        'Minimal Animation Time'."
    default = 100
    lowerBound = 0
    targets parents
}

global option layoutAncestors: boolean {
    label "Layout Ancestors"
    description
        "Whether the hierarchy levels on the path from the selected element to the root of the
        diagram shall be included in the layout process."
    default = false
    targets parents
}

global option maxAnimTime: int {
    label "Maximal Animation Time"
    description
        "The maximal time for animations, in milliseconds."
    default = 4000
    lowerBound = 0
    targets parents
}

global option minAnimTime: int {
    label "Minimal Animation Time"
    description
        "The minimal time for animations, in milliseconds."
    default = 400
    lowerBound = 0
    targets parents
}

global option progressBar: boolean {
    label "Progress Bar"
    description
        "Whether a progress bar shall be displayed during layout computations."
    default = false
    targets parents
}

global option validateGraph: boolean {
    label "Validate Graph"
    description
        "Whether the graph shall be validated before any layout algorithm is applied. If this
        option is enabled and at least one error is found, the layout process is aborted and a message
        is shown to the user."
    default = false
    targets parents
}

global option validateOptions: boolean {
    label "Validate Options"
    description
        "Whether layout options shall be validated before any layout algorithm is applied. If this
        option is enabled and at least one error is found, the layout process is aborted and a message
        is shown to the user."
    default = true
    targets parents
}

global option zoomToFit: boolean {
    label "Zoom to Fit"
    description
        "Whether the zoom level shall be set to view the whole diagram after layout."
    default = false
    targets parents
}

