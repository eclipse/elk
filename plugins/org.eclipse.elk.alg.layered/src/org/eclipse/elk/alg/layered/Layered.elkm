/*******************************************************************************
 * Copyright (c) 2015 Kiel University and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    spoenemann - initial API and implementation
 *******************************************************************************/
package org.eclipse.elk.alg.layered

import java.util.EnumSet
import org.eclipse.elk.alg.layered.LayeredLayoutProvider
import org.eclipse.elk.alg.layered.intermediate.NodePromotionStrategy
import org.eclipse.elk.alg.layered.intermediate.compaction.ConstraintCalculationStrategy
import org.eclipse.elk.alg.layered.intermediate.compaction.GraphCompactionStrategy
import org.eclipse.elk.alg.layered.p1cycles.CycleBreakingStrategy
import org.eclipse.elk.alg.layered.p2layers.LayeringStrategy
import org.eclipse.elk.alg.layered.p3order.CrossingMinimizationStrategy
import org.eclipse.elk.alg.layered.p4nodes.NodePlacementStrategy
import org.eclipse.elk.alg.layered.p4nodes.bk.EdgeStraighteningStrategy
import org.eclipse.elk.core.options.Direction
import org.eclipse.elk.core.options.EdgeLabelPlacementStrategy
import org.eclipse.elk.core.options.EdgeRouting
import org.eclipse.elk.core.options.PortAlignment
import org.eclipse.elk.core.util.ExclusiveBounds

/**
 * Declarations for the ELK Layered layout algorithm.
 */
bundle {
    metadataClass properties.LayeredMetaDataProvider  
    idPrefix org.eclipse.elk.layered  
}

algorithm layered(LayeredLayoutProvider) {
    label "ELK Layered"    
    description
        "Layer-based algorithm provided by the Eclipse Layout Kernel. Arranges as many edges as
        possible into one direction by placing nodes into subsequent layers. This implementation
        supports different routing styles (straight, orthogonal, splines); if orthogonal routing is
        selected, arbitrary port constraints are respected, thus enabling the layout of block
        diagrams such as actor-oriented models or circuit schematics. Furthermore, full layout of
        compound graphs with cross-hierarchy edges is supported when the respective option is
        activated on the top level."
    metadataClass properties.LayeredOptions
    category org.eclipse.elk.layered
    features self_loops, inside_self_loops, multi_edges, edge_labels, ports, compound, clusters
    preview images/layered.png
    supports org.eclipse.elk.spacing.node = 20
    supports org.eclipse.elk.spacing.border = 12
    supports org.eclipse.elk.spacing.port
    supports org.eclipse.elk.spacing.^label
    supports org.eclipse.elk.priority = 0
    supports org.eclipse.elk.edgeRouting = EdgeRouting.ORTHOGONAL
    supports org.eclipse.elk.port.borderOffset = 0
    supports org.eclipse.elk.randomSeed = 1
    supports org.eclipse.elk.aspectRatio = 1.6f
    supports org.eclipse.elk.noLayout
    supports org.eclipse.elk.portConstraints
    supports org.eclipse.elk.port.side
    supports org.eclipse.elk.debugMode
    supports org.eclipse.elk.alignment
    supports org.eclipse.elk.layoutHierarchy // TODO deprecated
    supports org.eclipse.elk.hierarchyHandling
    supports org.eclipse.elk.separateConnectedComponents = true
    supports org.eclipse.elk.insideSelfLoops.activate
    supports org.eclipse.elk.insideSelfLoops.yo
    supports org.eclipse.elk.nodeSize.constraints
    supports org.eclipse.elk.nodeSize.options
    supports org.eclipse.elk.direction = Direction.UNDEFINED
    supports org.eclipse.elk.nodeLabels.placement
    supports org.eclipse.elk.portLabels.placement
    supports org.eclipse.elk.portAlignment.basic = PortAlignment.JUSTIFIED
    supports org.eclipse.elk.portAlignment.north
    supports org.eclipse.elk.portAlignment.south
    supports org.eclipse.elk.portAlignment.west
    supports org.eclipse.elk.portAlignment.east
    supports org.eclipse.elk.alg.layered.spacing.edgeNodeSpacingFactor
    supports org.eclipse.elk.alg.layered.spacing.edgeSpacingFactor
    supports unnecessaryBendpoints
    supports org.eclipse.elk.alg.layered.layering.strategy
    supports org.eclipse.elk.alg.layered.layering.nodePromotion.strategy
    supports thoroughness
    supports org.eclipse.elk.alg.layered.layering.layerConstraint
    supports org.eclipse.elk.alg.layered.cycleBreaking.strategy
    supports org.eclipse.elk.alg.layered.crossingMinimization.strategy
    supports org.eclipse.elk.alg.layered.crossingMinimization.hierarchicalSweepiness
    supports org.eclipse.elk.alg.layered.crossingMinimization.greedySwitch
    supports org.eclipse.elk.alg.layered.crossingMinimization.semiInteractive
    supports mergeEdges
    supports mergeHierarchyEdges
    supports interactiveReferencePoint
    supports org.eclipse.elk.alg.layered.nodePlacement.strategy
    supports org.eclipse.elk.alg.layered.nodePlacement.bk.fixedAlignment
    supports edgeLabelSideSelection
    supports feedbackEdges
    supports org.eclipse.elk.alg.layered.spacing.inLayerSpacingFactor
    supports org.eclipse.elk.alg.layered.layering.wideNodesOnMultipleLayers
    supports org.eclipse.elk.alg.layered.nodePlacement.linearSegments.deflectionDampening
    supports org.eclipse.elk.alg.layered.edgeRouting.selfLoopPlacement
    supports contentAlignment
    supports org.eclipse.elk.alg.layered.nodePlacement.bk.edgeStraightening
    supports org.eclipse.elk.alg.layered.compaction.postCompaction.strategy
    supports org.eclipse.elk.alg.layered.compaction.postCompaction.constraints
    supports org.eclipse.elk.alg.layered.compaction.connectedComponents
    supports org.eclipse.elk.alg.layered.highDegreeNodes.treatment
    supports org.eclipse.elk.alg.layered.highDegreeNodes.threshold
    supports org.eclipse.elk.alg.layered.highDegreeNodes.treeHeight
    supports org.eclipse.elk.nodeSize.minimum
    supports org.eclipse.elk.nodeSize.minWidth
    supports org.eclipse.elk.nodeSize.minHeight
    supports org.eclipse.elk.junctionPoints
    supports org.eclipse.elk.edge.thickness
    supports org.eclipse.elk.edgeLabels.placement
    supports org.eclipse.elk.port.index
    supports org.eclipse.elk.commentBox
    supports org.eclipse.elk.hypernode
    supports org.eclipse.elk.port.anchor
    supports org.eclipse.elk.partitioning.activate
    supports org.eclipse.elk.partitioning.partition
    supports org.eclipse.elk.alg.layered.layering.distributeNodes
    supports org.eclipse.elk.alg.layered.layering.minWidth.upperBoundOnWidth
    supports org.eclipse.elk.alg.layered.layering.minWidth.upperLayerEstimationScalingFactor
    supports sausageFolding
    supports org.eclipse.elk.position
    supports northOrSouthPort
    supports org.eclipse.elk.alg.layered.layering.nodePromotion.maxIterations
    supports edgeCenterLabelPlacementStrategy
    supports org.eclipse.elk.margins
    supports edgeRouting.sloppySplineRouting
    supports edgeRouting.sloppySplineLayerSpacing
    supports layering.coffmanGraham.layerBound
}


/* ------------------------
 *    phase 1
 * ------------------------*/
group cycleBreaking {
    
    option strategy: CycleBreakingStrategy {
        label "Cycle Breaking Strategy"
        description
            "Strategy for cycle breaking. Cycle breaking looks for cycles in the graph and determines
            which edges to reverse to break the cycles. Reversed edges will end up pointing to the
            opposite direction of regular edges (that is, reversed edges will point left if edges
            usually point right)."
        default = CycleBreakingStrategy.GREEDY
        targets parents
        legacyIds de.cau.cs.kieler.klay.layered.cycleBreaking
    }
    
}


/* ------------------------
 *    phase 2
 * ------------------------*/
group layering {
    
    option strategy: LayeringStrategy {
        label "Node Layering Strategy"
        description "Strategy for node layering."
        default = LayeringStrategy.NETWORK_SIMPLEX
        targets parents
        legacyIds de.cau.cs.kieler.klay.layered.nodeLayering
    }
    
    advanced option layerConstraint: LayerConstraint {
        label "Layer Constraint"
        description "Determines a constraint on the placement of the node regarding the layering."
        default = LayerConstraint.NONE
        targets parents
        legacyIds de.cau.cs.kieler.klay.layered.layerConstraint
    }
    
    deprecated advanced option distributeNodes: boolean {
        label "Distribute Nodes (Deprecated)"
        description "Whether wide nodes should be distributed to several layers."
        default = false
        targets parents
        legacyIds de.cau.cs.kieler.klay.layered.distributeNodes
    }

    advanced option wideNodesOnMultipleLayers: WideNodesStrategy {
        label "Wide Nodes on Multiple Layers"
        description "Strategy to distribute wide nodes over multiple layers."
        default = WideNodesStrategy.OFF
        targets parents
        legacyIds de.cau.cs.kieler.klay.layered.wideNodesOnMultipleLayers
    }
    
    
    group minWidth {
        
        advanced option upperBoundOnWidth: int {
            label "Upper Bound On Width [MinWidth Layerer]"
            description "Defines a loose upper bound on the width of the MinWidth layerer."
            default = 4
            lowerBound = 1
            targets parents
            legacyIds de.cau.cs.kieler.klay.layered.minWidthUpperBoundOnWidth
            requires org.eclipse.elk.alg.layered.layering.strategy == LayeringStrategy.EXP_MIN_WIDTH
        }
        
        advanced option upperLayerEstimationScalingFactor: int {
            label "Upper Layer Estimation Scaling Factor [MinWidth Layerer]"
            description
                "Multiplied with Upper Bound On Width for defining an upper bound on the width of layers which
                haven't been determined yet, but whose maximum width had been (roughly) estimated by the MinWidth
                algorithm. Compensates for too high estimations."
            default = 2
            lowerBound = 1
            targets parents
            legacyIds de.cau.cs.kieler.klay.layered.minWidthUpperLayerEstimationScalingFactor
            requires org.eclipse.elk.alg.layered.layering.strategy == LayeringStrategy.EXP_MIN_WIDTH
        }
        
    }
    
    group nodePromotion {
        
        advanced option strategy: NodePromotionStrategy {
            label "Node Promotion Strategy"
            description "Reduces number of dummy nodes after layering phase (if possible)."
            default = NodePromotionStrategy.NONE
            targets parents
            legacyIds de.cau.cs.kieler.klay.layered.nodePromotion
        }
        
        advanced option maxIterations: int {
            label "Max Node Promotion Iterations"
            description "Limits the number of iterations for node promotion."
            default = 0
            lowerBound = 0
            targets parents
            legacyIds de.cau.cs.kieler.klay.layered.nodePromotionBoundary
            requires org.eclipse.elk.alg.layered.layering.nodePromotion.strategy
        }

    }
    
    group coffmanGraham {
        
        advanced option layerBound: int {
            label "Layer Bound"
            description "The maximum number of nodes allowed per layer."
            default = Integer.MAX_VALUE
            targets parents
            requires org.eclipse.elk.alg.layered.layering.strategy == LayeringStrategy.COFFMAN_GRAHAM
        }
        
    }
}


/* ------------------------
 *    phase 3
 * ------------------------*/
group crossingMinimization {
    
    option strategy: CrossingMinimizationStrategy {
        label "Crossing Minimization Strategy"
        description "Strategy for crossing minimization."
        default = CrossingMinimizationStrategy.LAYER_SWEEP
        targets parents
        legacyIds de.cau.cs.kieler.klay.layered.crossMin
    } 
    
    option hierarchicalSweepiness: float {
        label "Hierarchical Sweepiness"
        description "How likely it is to use cross-hierarchy (1) vs bottom-up (-1)."  
        default = 0.1f
        targets parents 
    }
    
    /** 
     * Greedy switch type is not used internally, here we use the CrossMinType enum defined in the
     * LayerSweep class. This is only used for user interaction.
     */
    advanced option greedySwitch: GreedySwitchType {
        label "Greedy Switch Crossing Minimization"
        description "Greedy Switch strategy for crossing minimization."
        default = GreedySwitchType.TWO_SIDED
        targets parents
        legacyIds de.cau.cs.kieler.klay.layered.greedySwitch
    }
    
    advanced option semiInteractive: boolean {
        label "Semi-Interactive Crossing Minimization"
        description 
            "Preserves the order of nodes within a layer but still minimizes 
             crossings between edges connecting long edge dummies. 
             Requires a crossing minimization strategy that is able to 
             process 'in-layer' constraints."
        default = false
        targets parents
    }
    
}


/* ------------------------
 *    phase 4
 * ------------------------*/
group nodePlacement {

    option strategy: NodePlacementStrategy {
        label "Node Placement Strategy"
        description "Strategy for node placement."
        default = NodePlacementStrategy.BRANDES_KOEPF
        targets parents
        legacyIds de.cau.cs.kieler.klay.layered.nodePlacement
    }
    
    group bk {
        
        advanced option edgeStraightening: EdgeStraighteningStrategy {
            label "Edge Straightening"
            description
                "Specifies whether the Brandes Koepf node placer tries to increase the number of straight edges
                at the expense of diagram size."
            default = EdgeStraighteningStrategy.IMPROVE_STRAIGHTNESS
            targets parents
            legacyIds de.cau.cs.kieler.klay.layered.nodeplace.compactionStrategy
            requires org.eclipse.elk.alg.layered.nodePlacement.strategy == NodePlacementStrategy.BRANDES_KOEPF
        }
        
        // TODO Turn this into two layout options
        advanced option fixedAlignment: FixedAlignment {
            label "Fixed Alignment"
            description
                "Tells the BK node placer to use a certain alignment instead of taking the optimal result."
            default = FixedAlignment.NONE
            targets parents
            legacyIds de.cau.cs.kieler.klay.layered.fixedAlignment
            requires org.eclipse.elk.alg.layered.nodePlacement.strategy == NodePlacementStrategy.BRANDES_KOEPF
        }
        
    }
    
    
    group linearSegments {
        
        advanced option deflectionDampening: float {
            label "Linear Segments Deflection Dampening"
            description "Dampens the movement of nodes to keep the diagram from getting too large."
            default = 0.3f
            lowerBound = ExclusiveBounds.greaterThan(0)
            targets parents
            legacyIds de.cau.cs.kieler.klay.layered.linearSegmentsDeflectionDampening
            requires org.eclipse.elk.alg.layered.nodePlacement.strategy == NodePlacementStrategy.LINEAR_SEGMENTS
        }
        
    }
    
}


/* ------------------------
 *    phase 5
 * ------------------------*/
group edgeRouting {

    option selfLoopPlacement: SelfLoopPlacement {
        label "Spline Self-Loop Placement"
        default = SelfLoopPlacement.NORTH_STACKED
        targets parents
        legacyIds de.cau.cs.kieler.klay.layered.splines.selfLoopPlacement
        requires org.eclipse.elk.edgeRouting == EdgeRouting.SPLINES
    }

    option sloppySplineRouting: boolean {
        label "Sloppy Spline Routing"
        description 
            "Use less spline control points at the start and end of an edge. Might lead to crossings edge/node overlap."
        default = true
        targets parents
        requires org.eclipse.elk.edgeRouting == EdgeRouting.SPLINES
    }
    
    option sloppySplineLayerSpacing: float {
        label "Sloppy Spline Layer Spacing Factor"
        description "Spacing factor for routing area between layers when using sloppy spline routing."
        default = 0.4f
        targets parents
        requires org.eclipse.elk.edgeRouting == EdgeRouting.SPLINES
        requires sloppySplineRouting == true
    }
}


/* ------------------------
 *    spacing
 * ------------------------*/
group spacing {

    advanced option edgeNodeSpacingFactor: float {
        label "Edge Node Spacing Factor"
        description
            "Factor by which the object spacing is multiplied to arrive at the minimal spacing between
            an edge and a node."
        default = 0.5f
        lowerBound = ExclusiveBounds.greaterThan(0)
        targets parents
        legacyIds de.cau.cs.kieler.klay.layered.edgeNodeSpacingFactor
    }
    
    advanced option edgeSpacingFactor: float {
        label "Edge Spacing Factor"
        description
            "Factor by which the object spacing is multiplied to arrive at the minimal spacing between
            edges."
        default = 0.5f
        lowerBound = ExclusiveBounds.greaterThan(0)
        targets parents
        legacyIds de.cau.cs.kieler.klay.layered.edgeSpacingFactor
    }
    
    advanced option inLayerSpacingFactor: float {
        label "In-layer Spacing Factor"
        description
            "Factor by which the usual spacing is multiplied to determine the in-layer spacing between
            objects."
        default = 1
        lowerBound = ExclusiveBounds.greaterThan(0)
        targets parents
        legacyIds de.cau.cs.kieler.klay.layered.inLayerSpacingFactor
    }
    
}


/* ------------------------
 *    compaction
 * ------------------------*/
group compaction {
    
    group postCompaction {
        
        advanced option strategy: GraphCompactionStrategy {
            label "Post Compaction Strategy"
            description "Specifies whether and how post-process compaction is applied."
            default = GraphCompactionStrategy.NONE
            targets parents
            legacyIds de.cau.cs.kieler.klay.layered.postCompaction
        }
        
        advanced option constraints: ConstraintCalculationStrategy {
            label "Post Compaction Constraint Calculation"
            description "Specifies whether and how post-process compaction is applied."
            default = ConstraintCalculationStrategy.SCANLINE
            targets parents
            legacyIds de.cau.cs.kieler.klay.layered.postCompaction.constraints
        }
        
    }
    
    advanced option connectedComponents: boolean {
        label "Connected Components Compaction"
        description "Tries to further compact components (disconnected sub-graphs)."
        default = false
        targets parents
        legacyIds de.cau.cs.kieler.klay.layered.components.compact
        requires org.eclipse.elk.separateConnectedComponents == true
    }
    
}


/* ------------------------
 *    high degree nodes
 * ------------------------*/
group highDegreeNodes {
    
    advanced option treatment: boolean {
        label "High Degree Node Treatment"
        description "Makes room around high degree nodes to place leafs and trees."
        default = false
        targets parents
        legacyIds de.cau.cs.kieler.klay.layered.highDegreeNode.treatment
    }
    
    advanced option threshold: int {
        label "High Degree Node Threshold"
        description "Whether a node is considered to have a high degree."
        default = 16
        lowerBound = 0
        targets parents
        legacyIds de.cau.cs.kieler.klay.layered.highDegreeNode.threshold
        requires org.eclipse.elk.alg.layered.highDegreeNodes.treatment == true
    }
    
    advanced option treeHeight: int {
        label "High Degree Node Maximum Tree Height"
        description "Maximum height of a subtree connected to a high degree node to be moved to separate layers."
        default = 5
        lowerBound = 0
        targets parents
        legacyIds de.cau.cs.kieler.klay.layered.highDegreeNode.treeHeight
        requires org.eclipse.elk.alg.layered.highDegreeNodes.treatment == true
    }

}


/* ------------------------
 *    miscellaneous
 * ------------------------*/
advanced option contentAlignment: EnumSet<ContentAlignment> {
    label "Content Alignment"
    description "Specifies how the content of compound nodes is to be aligned, e.g. top-left."
    default = EnumSet.noneOf(ContentAlignment)
    targets parents
    legacyIds de.cau.cs.kieler.klay.layered.contentAlignment
}

advanced option edgeCenterLabelPlacementStrategy: EdgeLabelPlacementStrategy {
    label "Edge Label Placement Strategy"
    description "Determines in which layer center labels of long edges should be placed."
    default = EdgeLabelPlacementStrategy.CENTER
    targets parents
    legacyIds de.cau.cs.kieler.edgeLabelPlacementStrategy
}

option edgeLabelSideSelection: EdgeLabelSideSelection {
    label "Edge Label Side Selection"
    description "Method to decide on edge label sides."
    default = EdgeLabelSideSelection.ALWAYS_DOWN
    targets parents
    legacyIds de.cau.cs.kieler.klay.layered.edgeLabelSideSelection
    requires org.eclipse.elk.edgeRouting == EdgeRouting.ORTHOGONAL
}

advanced option feedbackEdges: boolean {
    label "Feedback Edges"
    description "Whether feedback edges should be highlighted by routing around the nodes."
    default = false
    targets parents
    legacyIds de.cau.cs.kieler.klay.layered.feedBackEdges
}

advanced option interactiveReferencePoint: InteractiveReferencePoint {
    label "Interactive Reference Point"
    description "Determines which point of a node is considered by interactive layout phases."
    default = InteractiveReferencePoint.CENTER
    targets parents
    legacyIds de.cau.cs.kieler.klay.layered.interactiveReferencePoint
    requires org.eclipse.elk.alg.layered.cycleBreaking.strategy == CycleBreakingStrategy.INTERACTIVE
    requires org.eclipse.elk.alg.layered.crossingMinimization.strategy == CrossingMinimizationStrategy.INTERACTIVE
}

advanced option mergeEdges: boolean {
    label "Merge Edges"
    description
        "Edges that have no ports are merged so they touch the connected nodes at the same points.
        When this option is disabled, one port is created for each edge directly connected to a
        node. When it is enabled, all such incoming edges share an input port, and all outgoing
        edges share an output port."
    default = false
    targets parents
    legacyIds de.cau.cs.kieler.klay.layered.mergeEdges
}

advanced option mergeHierarchyEdges: boolean {
    label "Merge Hierarchy-Crossing Edges"
    description
        "If hierarchical layout is active, hierarchy-crossing edges use as few hierarchical ports
        as possible. They are broken by the algorithm, with hierarchical ports inserted as
        required. Usually, one such port is created for each edge at each hierarchy crossing point.
        With this option set to true, we try to create as few hierarchical ports as possible in
        the process. In particular, all edges that form a hyperedge can share a port."
    default = true
    targets parents
    legacyIds de.cau.cs.kieler.klay.layered.mergeHierarchyEdges
}

advanced option sausageFolding: boolean {
    label "Sausage Folding"
    description "Whether long sausages should be folded up nice and tight."
    default = false
    targets parents
    legacyIds de.cau.cs.kieler.klay.layered.sausageFolding
    requires org.eclipse.elk.alg.layered.layering.strategy == LayeringStrategy.LONGEST_PATH
}

advanced option thoroughness: int {
	label "Thoroughness"
	description "How much effort should be spent to produce a nice layout."
	default = 7
    lowerBound = 1
	targets parents
	legacyIds de.cau.cs.kieler.klay.layered.thoroughness
}

advanced option unnecessaryBendpoints: boolean {
    label "Add Unnecessary Bendpoints"
    description
        "Adds bend points even if an edge does not change direction. If true, each long edge dummy
        will contribute a bend point to its edges and hierarchy-crossing edges will always get a
        bend point where they cross hierarchy boundaries. By default, bend points are only added
        where an edge changes direction."
    default = false
    targets parents
    legacyIds de.cau.cs.kieler.klay.layered.unnecessaryBendpoints
}

advanced option northOrSouthPort: boolean {
    label "North or South Port"
    description
        "Specifies that this port can either be placed on the north side of a node or on the south
        side (if port constraints permit)"
    default = false
    targets ports
    legacyIds de.cau.cs.kieler.klay.layered.northOrSouthPort
}
